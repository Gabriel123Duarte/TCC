\chapter{Desenvolvimento (Alterar Nome) }
\label{chap:desenvolvimento}

Aqui entra o desenvolvimento real do trabalho com as principais técnicas de otimização

\section{Redução de espaço}
Dentre as otimizações disponíveis, as que envolvem redução de memória são as mais simples de serem aplicadas, seu uso pode ser facilmente entendido no problema da mochila \footnote{http://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/}. Esse problema deseja maximar o valor dos itens colocados em uma mochila, onde estes possuem um valor e um peso associado, enquanto a mochila possui uma capacidade máxima de peso. Além disso, nenhum item pode ser dividido.  

\begin{equation}
dp[i][j] = 
\begin{cases}
0 &\text{se } i = 0 \text{ ou } j = 0,\\
max(valor[i-1] + dp[i-1][j-peso[i-1]], dp[i-1][j]) &\text{se } peso[i-1] \leq{j},\\
dp[i-1][j] &\text{se } peso[i-1] > j
\end{cases}
\label{eq:knapsack}
\end{equation}

O problema da mochila pode ser resolvido através da relação de recorrência apresentada acima, onde $dp[i][j]$ representa o valor máximo que pode se conseguir ao colocar os $i$-ésimos primeiros itens em uma mochila de capacidade $j$. Os vetores $valor$ e $peso$, representam o valor e peso associado a cada um dos $n$ itens, respectivamente. A resposta para o problema estará em $dp[n][capacidade]$.

Analisando a complexidade da equação \ref{eq:knapsack} é fácil ver que será necessário $O(n*capacidade)$, tanto de memória, quanto de tempo. Porém, é notório que para solucionar a linha $i$ da matriz de programação dinâmica, só são necessárias as respostas que já foram calculadas na linha $i - 1$, portanto podemos trabalhar apenas com duas linhas consecutivas da matriz, sempre alternando entre linha par e ímpar. 

\begin{equation}
dp[i\&1][j] = 
\begin{cases}
0 &\text{se } i = 0 \text{ ou } j = 0,\\

max(valor[i-1] + dp[\text{\textasciitilde}i\&1][j-peso[i-1]], dp[\text{\textasciitilde}i\&1][j]) &\text{se } peso[i-1] \leq{j},\\
dp[\text{\textasciitilde}i\&1][j] &\text{se } peso[i-1] > j
\end{cases}
\label{eq:knapsackmemorialinear}
\end{equation}

A equação \ref{eq:knapsackmemorialinear} demostra como reduzir a memória. Os valores que serão utilizados nas linhas da DP serão sempre 0 ou 1, assim o total de memória necessária é de $2*capacidade$, deixando com uma complexidade de $O(capacidade)$. A resposta para o problema da mochila utilizando esta relação estará em $dp[n\&1][capacidade]$.

O seguinte código mostra a implementação do problema da mochila com memória linear.
\begin{lstlisting}[caption={Implementação Mochila},label={lst:lis}]

int mochila(){
	int valor[] = {60, 100, 120};
	int peso[]  = {10, 20, 30};
	int capacidade = 50, n = 3;
	
	int dp[2][capacidade + 1];
	for(int i = 0; i <= n; i++){
		for(int j = 0; j <= capacidade; j++){
			if(!i || !j)
				dp[i&1][j] = 0;
			else if(peso[i - 1] <= j)
				dp[i&1][j] = max(valor[i-1] + dp[~i&1][j-peso[i-1]],
				                 dp[~i&1][j]);
			else
				dp[i&1][j] = dp[~si&1][j];
		}
	}
	return dp[n&1][capacidade]; 
}
\end{lstlisting}

\section{Estrutura de dados RMQ}

Um dos problemas clássicos de programação dinâmica é o\sigla{LIS}{Longest Increasing Subsequence}(do inglês, \textit{Longest Increasing Subsequence}). Neste, o objetivo é encontrar a maior subsequência de um \textit{array} onde todos os elementos estão ordenados de forma crescente.

Imaginemos o seguinte \textit{array}:

\begin{center}
	${2, 5, 3, 7, 11, 8}$
\end{center}

Uma das solução para este conjunto é a subsequência ${2, 3, 7, 8}$, que possui tamanho quatro.

Para resolver este problema pode ser usado programação dinâmica com a seguinte recorrência:

\begin{equation}
dp[i] = 
\begin{cases}
1 &\text{se } i = 0 \\
max(dp[j] + 1)_{0 \leq j < i} &\text{se } i \neq 0 \text{ e } v[j] \leq v[i]

\end{cases}
\label{eq:lisQuadrado}
\end{equation}

A equação \ref{eq:lisQuadrado}, resolve o problema do LIS, com a complexidade $O(n^2)$ de tempo e $O(n)$ de memória, porém é notório que quando está sendo calculado a $dp[i]$, ou seja, a maior LIS que termina no $i$-ésimo índice, está sendo percorrido todos elementos do $array$ que estão a esquerda e que possuem um valor menor ou igual que o elemento atual. Em outras palavras, queremos o maior elemento da $dp$ que seu valor está no intervalo $[0..v[i]]$.

A partir destas observações podemos melhorar a complexidade dessa solução com o auxílio de uma estrutura de dados que consegue consultar máximo ou mínimo de intervalo de um $array$ de forma mais eficiente. Pode ser ela uma $Segment Tree$\footnote{http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/} ou $BIT$\footnote{http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/}, com isso é possível remover a busca linear no \textit{array} pelo maior elemento e trocar por uma busca logarítmica, deixando a solução final com $O(n*logn)$.

O código a seguir mostra uma maneira de implementar o LIS utilizando $BIT$.
\begin{lstlisting}[caption={Implementação LIS},label={lst:lis}]

#define MAXN 20
int v[] = {2, 5, 3, 7, 11, 8};
int bit[MAXN];
int dp[MAXN];

void update(int x, int v){
	for(; x < MAXN; x+=x&-x)
		bit[x] = max(bit[x], v);
}

int get(int x){
	int ans = 0;
	for(; x; x-=x&-x)
		ans = max(ans, bit[x]);
	return ans;
}

int lis(int n){
	int ans = 0;
	
	for(int i = 0; i < n; i++){
		dp[i] = 1+get(v[i]);
		update(v[i], dp[i]);
		ans = max(ans, dp[i]);
	}
	
	return ans;
}
\end{lstlisting}

\section{Divide and Conquer Optimization}
Problemas:

\begin{itemize}
	\item Kattis Branch Assignment WF 2016
\end{itemize}

\section{Knuth Optimization}
Problemas:
\begin{itemize}
	\item Codechef = CHEFAOR
	\item URI 2475
\end{itemize}

\section{Convex Hull Trick}
Problemas:
\begin{itemize}
	\item URI 2481
\end{itemize}

