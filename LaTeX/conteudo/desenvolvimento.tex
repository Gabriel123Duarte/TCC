\chapter{Desenvolvimento (Alterar Nome) }
\label{chap:desenvolvimento}

Nesta seção serão apresentadas algumas técnicas de otimização para programação dinâmica, estas serão dividas em subseções, sendo cada uma das independentes entre si.

\section{Redução de espaço}

\begin{itemize}
\item \textbf{Problema:}
 São dados diversos itens e cada um possui um peso e valor associado, deseja-se colocar alguns em uma mochila\footnote{http://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/} com a finalidade de maximizar o valor dos que foram selecionados. Porém a mochila possui uma capacidade máxima de peso. Além disso, nenhum item pode ser dividido.
 \\
\item \textbf{Solução ingênua:} 
\begin{equation}
dp[i][j] = 
\begin{cases}
0 &\text{se } i = 0 \text{ ou } j = 0,\\
max(valor[i-1] + dp[i-1][j-peso[i-1]], dp[i-1][j]) &\text{se } peso[i-1] \leq{j},\\
dp[i-1][j] &\text{se } peso[i-1] > j
\end{cases}
\label{eq:knapsack}
\end{equation}

O problema da mochila pode ser resolvido através da relação de recorrência apresentada acima, onde $dp[i][j]$ representa o valor máximo que pode se conseguir ao colocar os $i$-ésimos primeiros itens em uma mochila de capacidade $j$. Os vetores $valor$ e $peso$, representam o valor e peso associado a cada um dos $n$ itens, respectivamente. A resposta para o problema estará em $dp[n][capacidade]$.


\item \textbf{Análise de particularidades:}
Analisando a complexidade da equação \ref{eq:knapsack} é fácil ver que será necessário $O(n*capacidade)$, tanto de memória, quanto de tempo. Porém, é notório que para solucionar a linha $i$ da matriz de programação dinâmica, só são necessárias as respostas que já foram calculadas na linha $i - 1$.


\item \textbf{Redução de espaço:} 
Esta técnica visa solucionar problemas onde a quantidade de memória alocada não é sempre necessária, fazendo com que seja mantido em memória apenas o essencial. Para todos os problemas onde uma linha de uma tabela da programação dinâmica dependa de uma quantidade fixa de outras linhas, digamos $K$, é necessário apenas manter em memória $K$ linhas.

Voltando ao problema proposto foi analisado que uma linha depende de apenas uma outra, portanto podemos trabalhar apenas com duas linhas consecutivas da matriz, sempre alternando entre linha par e ímpar. 
A equação abaixo demonstra como fazer essa alternância entre linhas:
\begin{equation}
dp[i\&1][j] = \\
\begin{cases}
0 &\text{se } i = 0 \text{ ou } j = 0,\\

max(valor[i-1] + dp[\text{\textasciitilde}i\&1][j-peso[i-1]],\\ dp[\text{\textasciitilde}i\&1][j]) &\text{se } peso[i-1] \leq{j},\\
dp[\text{\textasciitilde}i\&1][j] &\text{se } peso[i-1] > j
\end{cases}
\label{eq:knapsackmemorialinear}
\end{equation}

\tikz[baseline=-4pt,align=left]\node[draw,minimum width=12.5cm,minimum height=4ex]
{\textit{Sugere-se ao leitor tentar utilizar essa técnica na resolução do Fibonacci, que foi} \\\textit{explicado no capítulo \ref{chap:desenvolvimento}}. };
\\
\item \textbf{Benefícios:} 
A equação \ref{eq:knapsackmemorialinear} ilustra como reduzir a memória. Os valores que serão utilizados nas linhas da tabela de programação dinâmica serão sempre 0 ou 1, assim o total de memória necessária é de $2*capacidade$, deixando com uma complexidade de espacial de $O(capacidade)$. A resposta para o problema da mochila utilizando esta relação estará em $dp[n\&1][capacidade]$.


\item \textbf{Código final:} 
O seguinte código mostra a implementação do problema da mochila com memória linear.
\begin{lstlisting}[caption={Implementação Mochila},label={lst:lis}]

int mochila(){
	int valor[] = {60, 100, 120};
	int peso[]  = {10, 20, 30};
	int capacidade = 50, n = 3;

	int dp[2][capacidade + 1];
	for(int i = 0; i <= n; i++){
		for(int j = 0; j <= capacidade; j++){
			if(!i || !j)
				dp[i&1][j] = 0;
			else if(peso[i - 1] <= j)
				dp[i&1][j] = max(valor[i-1] + dp[~i&1][j-peso[i-1]],
				dp[~i&1][j]);
			else
				dp[i&1][j] = dp[~i&1][j];
		}
	}
	return dp[n&1][capacidade]; 
}
\end{lstlisting}
\end{itemize}








\section{Estrutura de dados RMQ}

\begin{itemize}
 \item \textbf{Problema:} Um dos problemas clássicos de programação dinâmica é o\sigla{LIS}{Longest Increasing Subsequence}(do inglês, \textit{Longest Increasing Subsequence})\footnote{http://www.geeksforgeeks.org/longest-increasing-subsequence/}. Neste, o objetivo é encontrar a maior subsequência de um \textit{array} onde todos os elementos estão ordenados de forma crescente. Uma subsequência pode ser encontrada com a eliminação de alguns elemento do \textit{array}.

Imaginemos o seguinte \textit{array}:

\begin{center}
	${2, 5, 3, 7, 11, 8}$
\end{center}

Uma das solução para este conjunto é a subsequência ${2, 3, 7, 8}$, que possui tamanho quatro, porém esta não é única, existem outras com o mesmo tamanho, como é o caso da subsequência ${2, 5, 7, 11}$. Geralmente é esperado apenas o tamanho da maior LIS possível. Portanto, qual LIS será escolhida não terá muita relevância, só será necessário se preocupar com isso quando houver a necessidade da reconstrução da solução.

\item \textbf{Solução ingênua:} Este problema pode ser facilmente resolvido com o auxilio de programação dinâmica utilizando a seguinte recorrência:

\begin{equation}
dp[i] = 
\begin{cases}
1 &\text{se } i = 0 \\
max(dp[j] + 1)_{0 \leq j < i} &\text{se } i \neq 0 \text{ e } v[j] \leq v[i]

\end{cases}
\label{eq:lisQuadrado}
\end{equation}

A equação \ref{eq:lisQuadrado}, resolve o problema do LIS, com a complexidade $O(n^2)$ de tempo e $O(n)$ de memória. Nesta solução $dp[i]$ representa qual a maior LIS que pode ser formada onde o último elemento é exatamente o índice $i$. Para calcular cada estado $i$ é selecionado um estado $j$ que já tenha sido calculado e possui maior valor, além disso o valor do elemento $j$ tem que ser menor ou igual que o elemento $i$. Isto significa que a LIS que termina em $i$ é uma junção da LIS terminada em $j$ adicionado o elemento $i$ ao final dela. Após calcular todos os estados utilizando a recorrência, basta percorrer o $array$ $dp$ e pegar o maior valor dele.

\item \textbf{Análise de particularidades:} É notório que quando está sendo calculado a $dp[i]$, ou seja, a maior LIS que termina no $i$-ésimo índice, está sendo percorrido todos elementos do $array$ que estão a esquerda e que possuem um valor menor ou igual que o elemento atual. Em outras palavras, queremos o maior elemento da $dp$ que seu valor está no intervalo $[0..v[i]]$.
\\

\tikz[baseline=-4pt,align=left]\node[draw,minimum width=12.5cm,minimum height=4ex]
{\textit{Sugere-se ao leitor pensar uma maneira mais eficiente de encontrar o maior elemento} \\\textit{ do array}. };
\\

\item \textbf{Estruturas de dados RMQ:}
Existem algumas estruturas de dados que resolvem problemas parecidos com este, onde é dado um \textit{array} e é necessário consultar o máximo ou mínimo elemento em um determinado intervalo, estas operações normalmente são chamadas de\sigla{RMQ}{Range Minimum Query}(do inglês, \textit{Range Minimum Query}). Espera-se destas estruturas uma complexidade melhor que $O(n)$, que seria a forma mais simples de conseguir o máximo, bastando apenas iterar por todo o intervalo. É o 
caso da $Segment Tree$\footnote{http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/} ou $BIT$\footnote{http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/}, ambas realizam estas operações em $O(logn)$.

\item \textbf{Benefícios:} Ao remover a busca linear para encontrar o maior elemento já calculado e adicionando uma das estruturas citadas, a complexidade da busca será reduzida de $O(n)$ para $O(logn)$, deixando assim a LIS em uma complexidade final de $O(n*logn)$.

\item \textbf{Código final:} 
O código a seguir mostra uma maneira de implementar o LIS utilizando $BIT$.
\begin{lstlisting}[caption={Implementação LIS},label={lst:lis}]

#define MAXN 20
int v[] = {2, 5, 3, 7, 11, 8};
int bit[MAXN];
int dp[MAXN];

void update(int x, int v){
	for(; x < MAXN; x+=x&-x)
		bit[x] = max(bit[x], v);
}

int get(int x){
	int ans = 0;
	for(; x; x-=x&-x)
		ans = max(ans, bit[x]);
	return ans;
}

int lis(int n){
	int ans = 0;
	
	for(int i = 0; i < n; i++){
		dp[i] = 1+get(v[i]);
		update(v[i], dp[i]);
		ans = max(ans, dp[i]);
	}
	
	return ans;
}
\end{lstlisting}
\end{itemize}
\section{Divide and Conquer Optimization}
\begin{itemize}
\item \textbf{Problema:}
É dado $n$ objetos, cada um com um valor associado $x_{1}, x_{2}, x_{3}, ..., x_{n}$, onde $x_{i} > 0 _{\forall{i}}$ e é necessário dividi-los em $k$ grupos consecutivos, porém é necessário que esta divisão seja feita com o menor custo possível. O custo para criação de um grupo é igual a soma dos valores de todos elementos do grupo multiplicado pela quantidade de objetos.

Supondo que são quatro objetos e seus valores são {1, 2, 3, 4} e é necessário dividir estes em dois grupos. Uma divisão possível seria colocar os objetos com valores {1, 2, 3} no primeiro grupo o que resultaria em um custo de 18, ou seja, a soma deles que é igual a 6, multiplicado pela quantidade de elementos, 3. Por fim, o elemento 4 ficaria no segundo grupo, tendo como custo o valor 4. Portanto para esta configuração o custo total é a soma de todos os dois grupos, o que gera um valor de $18+4=22$. Analisando um pouco melhor este exemplo é fácil notar que esta configuração não é a melhor possível. A solução ótima seria deixar os objetos com valores 1 e 2 no primeiro grupo e os demais elementos no segundo grupo, gerando um custo total de 20.

\item \textbf{Solução ingênua:} Para resolver este problema o primeiro passo pode ser calcular uma matriz $C[i][j]$, que corresponde ao custo total  para agrupar todos os elementos do índice $i$ até o índice $j$. O tempo total para calcular a matriz poderá ser de ordem quadrática.
\\

\tikz[baseline=-4pt,align=left]\node[draw,minimum width=12.5cm,minimum height=4ex]
{\textit{Fica como sugestão ao leitor implementar o cálculo da matriz $C$ com tempo $O(n^2)$.}};
\\

A equação \ref{eq:dc1} exemplifica uma maneira de implementar o problema, onde $dp[i][j]$ representa o menor custo para criar $i$ grupos estando no $j$-ésimo objeto. A resposta estará em $dp[k][n]$, levando em consideração que o $array$ está indexado a partir da posição 1. Para solucionar cada estado é necessário percorrer todos os elementos que são menores que $j$ e verificar se criar um novo grupo naquela posição irá melhorar solução, para tal será feito em média $n/2$ iterações o que leva em uma complexidade final de $O(k*n^2)$.

\begin{equation}
dp[i][j] =
\begin{cases}
0 &\text{se } i = 0 \\
C[i][j] &\text{se } i = 1 \\
min_{l < j}(dp[i-1][l] + C[l+1][j]) &\text{se } i > 1
\end{cases}
\label{eq:dc1}
\end{equation}

\item \textbf{Análise de particularidades:} 
Se for definido uma matriz $opt[i][j]$ que representa qual é o $l$ ótimo para realizar a divisão da $dp[i][j]$, ou seja, o ponto ótimo que minimiza o valor daquele estado, é possível notar que para qualquer $i$ e $j$, $opt[i][j] \leq opt[i][j+1]$, portanto, $j$ é monotônico\footnote{https://en.wikipedia.org/wiki/Monotonic\_function} para um $i$ fixo. Isto é verdade pois ao inserir um novo objeto em um grupo o valor deste só poderá aumentar, devido a formulação da função de custo. Assim, um conjunto com $x+1$ elementos não poderá ter um ponto ótimo de divisão menor do que este mesmo conjunto com $x$ elementos.

\item \textbf{Divide and Conquer Optimization:} Devido a monotonicidade de $opt$, pode-se melhorar a complexidade da solução proposta, pois como observado, para calcular o estado ($i$, $j+1$), não é necessário testar valores de $l$ que são menores do que $opt[i][j]$, mas sim só é necessário os valores que são maiores ou iguais a $opt[i][j]$. Para a implementação desta técnica podemos recorrer a divisão e conquista\footnote{https://pt.wikipedia.org/wiki/Divisão\_e\_conquista}, onde pode-se criar uma função recursiva que para um $i$ fixo, é aplicado a divisão e conquista no $j$, sendo mantido o intervalo do $j$ e o intervalo válido de $l$, que representa o ponto ótimo.

\item \textbf{Benefícios:} Ao calcular o valor e o ponto ótimo $x$ para um estado $j$, a divisão em conquista se responsabilizará por chamar a recursão para resolver o estado $j-1$ com o intervalo de $l$ variando de $1..x$ e a recursão para o estado $j+1$ com o $l$ entre $x..n$, assim é perceptível que o intervalo de busca do ponto ótimo que no início era $0..n$, foi dividido pela metade, e este é exatamente o pior caso, quando o ótimo está exatamente no meio. Portanto para calcular um estado $j$ para um $i$ fixo, a complexidade é $O(n*logn)$, bem menor do que a solução ingênua que gastava $O(n^2)$ para cada $i$. Sendo assim, a complexidade final ao aplicar esta técnica neste problema fica $O(k*n*logn)$.
\item \textbf{Código final:} A seguir é apresentado um código que resolve este problema. Para obter a solução basta chamar a função $divideAndConquer()$, passando como parâmetro o total de elementos e a quantidade de grupos desejados.
\\

\tikz[baseline=-4pt,align=left]\node[draw,minimum width=12.5cm,minimum height=4ex]
{\textit{Fica como sugestão ao leitor resolver o problema 2475 - Confecção de Presentes} \\\textit{do site URI - Online Judge}};

\begin{lstlisting}[caption={Implementação Divide and Conquer},label={lst:dc}]
#define MAXN 10
#define inf 99999999

int arr[MAXN] = {1, 2, 3, 4};
int C[MAXN][MAXN], dp[MAXN][MAXN];

void solve(int i, int jInicio, int jFim, int optInicio, int optFim){
	if(jInicio > jFim)
	return;
	
	int mid = (jInicio + jFim) / 2;
	dp[i][mid] = inf;
	int opt = -1;
	
	for(int l = optInicio; l <= min(optFim, mid); l++){
		if(dp[i-1][l] + C[l+1][mid] < dp[i][mid]){
			dp[i][mid] = dp[i-1][l] + C[l+1][mid];
			opt = l;
		}
	}
	
	solve(i, jInicio, mid-1, optInicio, opt);
	solve(i, mid+1, jFim, opt, optFim);
}

int divideAndConquer(int n, int k){
	// Calculo da funcao custo O(n^2)
	for(int i = 0; i < n; i++){
		int soma = 0;
		for(int j = i; j < n; j++){
			soma += arr[j];
			C[i][j] = soma*(j-i+1);
		}
	}
	
	// Casos base
	for(int i = 0; i < n; i++)
		dp[0][i] = 0;
	for(int i = 0; i < n; i++)
		dp[1][i] = C[0][i];
	
	for(int i = 2; i <= k; i++)
		solve(i, 0, n-1, 0, n-1);
	
	return dp[k][n-1];
}

\end{lstlisting}
\end{itemize}
\section{Knuth Optimization}
\begin{itemize}
\item \textbf{Problema:}
\item \textbf{Solução ingênua:} 
\item \textbf{Análise de particularidades:}
\item \textbf{“Nome da técnica”:}
\item \textbf{Benefícios:}
\item \textbf{Código final:}
\end{itemize}
\begin{itemize}
	\item Codechef = CHEFAOR
	\item URI 2475
\end{itemize}

\section{Convex Hull Trick}
\begin{itemize}
	\item \textbf{Problema:}
	\item \textbf{Solução ingênua:} 
	\item \textbf{Análise de particularidades:}
	\item \textbf{“Nome da técnica”:}
	\item \textbf{Benefícios:}
	\item \textbf{Código final:}
\end{itemize}
\begin{itemize}
	\item URI 2481
\end{itemize}

